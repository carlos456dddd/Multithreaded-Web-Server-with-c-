# Multithreaded-Web-Server-with-c++

This is a personal project focused on a language that interests me, as well as a review of internal aspects to strengthen my knowledge. I have no set limits for its development, and it is purely educational from my perspective. To maintain a completely natural approach, I will not use AI assistance for writing the .md file. I want to keep it entirely original, meaning that the explanations will be written solely by me. References to the books used for each section will be provided, along with some reviews of the books, to offer my opinion on them. I'm not trying to criticize academic material, but rather to shorten the path for anyone reading this repository so that, if they're considering reading any of these books, they'll consider some tips. It's not just about learning the C++ language, but also about protocols and things we often overlook and don't really understand how they work internally. To make things more natural, I'll create diagrams manually, mainly so I can remember them myself, and if they're helpful to someone else, that's fine too. Many of the examples I'll use won't be overly technical, but rather presented in a way that makes complex concepts more accessible.

## Considerations
Before starting this project, I had to ask myself if I truly understood the process, or what it entailed. My answer was, "Honestly, I don't understand or remember anything." Then I had to consider how to achieve what I was planning, and for that, I consulted some books and watched YouTube videos before embarking on this journey.

## Bocks
Regarding books to consider, in this case, for the moment they are:

- HTTP Definitive Guide.

- UNIX Network Programming Volume 1, Third Edition: The Sockets Networking API.

I know I could try to directly extract the code and provide a general explanation, but honestly, I was curious about these topics after first delving into them with videos and a basic understanding I had from the Rust project book available online.

The first issue I addressed to understand what I was trying to do was understanding what happens in general, what occurs in the first interaction of the project I'm planning. Both books mention this from the beginning, referring to "client-server," which at first seemed familiar, and I had a basic understanding of the concept. My understanding was more along the lines of something that works in two directions: "Sends information - receives information and sends a response." This wasn't entirely wrong, but it was obviously a very simplistic way of explaining it, because the server at the micro level doesn't just receive and send responses so casually.

## After reading the books
What I understand at the moment is that to establish a connection, a protocol must first be established to determine how they will communicate. To put it simply and without interruption... This is a necessary process for establishing a connection. The elements that determine it are the application layer, which could be the HTTP protocol (Hypertext Transfer Protocol); the transport layer, TCP (Transmission Control Protocol), which breaks down the information from the previous layer (in this case, HTTP) and sends it in packets; and the network layer, IP (Internet Protocol), which in this case will allow us to communicate with the data link layer, whether we use IPv4 or IPv6. In the data link layer, we'll have things like internet drivers. While both books were quite concise, I found the UNIX explanation more introductory for a more user-friendly approach (so you can review it in more detail).

What I noticed is that the way it works is more like first deciding where to go, in this case HTTP; then choosing the transport company, in this case TCP; preparing our personal data to display, which in this case would be the IP address; and finally, taking the bus, which roughly corresponds to the drivers at the data link layer—you could think of it as a landline, I suppose. And finally, the router buses in the case of a LAN (Local Area Network) connection, which would be point-to-point, or for a longer journey, which would be a WAN (Wide Area Network), going from router to router to the destination. I think WAN sounds familiar, if that's what you're thinking. Honestly, when you look at the example, I don't think it's that complex when you use a real-life example.

![Client and server example](./images/client%20and%20server.png)

I hope this example gives you a clearer idea of ​​what I'm trying to explain. First, if you consider the first step, the character decides to take a trip, in this case by land, traveling by bus. You could associate this with the transmission of something; we're proposing something, in this case, it could be HTTP and everything that entails. Then we have the transport aspect, which is a type of transportation that has its own ways of carrying out journeys or transporting goods, whether by land or air, in this case, by land. We have IP, or the Internet Protocol, which can be either IPv4 or IPv6. I know it might be a bit confusing, but you could think of it as the set of rules behind the information about the person traveling, including their destination. This is where we'll find information about our seat on the bus and so on. Regarding the data link layer, which is the drivers section and the one that leads us to the routers, we could place it directly as the location of the land port, whether it will be for just one LAN connection or a set of routers, but for the example I think it is fine.